#1 Провести выкладки и обосновать...
n = 100
del = 0.0001
x = seq(0, (del * (n - 1)), del)
# B[i] = B[i - 1] + rnorm(1, 0, sqrt(del))
# Если в данной формуле расписать B[i-1] по этой же формуле, то можно получить
# Примем rnorm(1, 0, sqrt(del)) за e
# B[i] = B0 + e(1) + e(2) ... e(i)
# или
# B[i] = B0 + rnorm(i, 0, sqrt(del))
# Так как B0 = 0
# B[i] = rnorm(i, 0, sqrt(del))
# Т.е. B[i] сравнимо с средним значением случайной величины определенной rnorm(i, 0, sqrt(del))
# Так как в параметрах (по заданию), мы задаем 0-вое мат.ожидание.
# Соответственно все свойства взятой случайной величины подходят для B[i]

Broun = function(n) {
  B = 0
  for(i in 2:n) {
    B[i] = B[i - 1] + rnorm(1, 0, sqrt(del))
  }
  return(B)
}
br = Broun(n)
plot(x, br, type='l', ylim = c(-1, 1))

#2  
for(i in 2:200) {
  lines(x, Broun(n), type='l', col=i)
}
dover1 = (3 * sqrt((1:n) * del))
dover2 = -(3 * sqrt((1:n) * del))
lines(x, dover1, lty=2, lwd=3)
lines(x, dover2, lty=2, lwd=3)
# Как видно из графика большинство реализаций ограничены областью по правилу трех сигм,
# и только малая часть выходит за пределы

#3 Построить ансамбль реализаций процесса, замоделированного на предыдущем шаге,
# и вывести все реализации процесса на один график.
# Т.е. построить 200 реализаций процесса (8) на одном графике.

Ansabl = function(A0, a, d, n) {
  A = 0
  A = (A0 * exp(((1:n) * del) * (a - (d ** 2) / 2) + d * Broun(n)))
  return(A)
}
plot(x, Ansabl(1, 0.5, 0.9, n), type='l', ylim = c(0, 2))

#4 Построить 200 реализаций процесса (10) на одном графике.
for(i in 2:200) {
  lines(x, Ansabl(1, 0.5, 0.9, n), type='l', col=i)
}


